# What?

This repository contains a little python script to make writing an LV2 plugin a little less repetitive/painful.

# Requirements:

- Python 3
- regexec, if you want to rebuild the documentation (README.md): https://github.com/fps/regexec
- valgrind and sord, if you want to run the tests

# Usage

<pre>
usage: lv2-ttl2c [-h] [-b BUNDLE] [-o OUTPUT_DIRECTORY] [-p PREFIX]

Generate useful C code from a LV2 plugin bundle's metadata

optional arguments:
  -h, --help            show this help message and exit
  -b BUNDLE, --bundle BUNDLE
                        the bundle directory to analyze (default: .)
  -o OUTPUT_DIRECTORY, --output-directory OUTPUT_DIRECTORY
                        the output directory (default: .)
  -p PREFIX, --prefix PREFIX
                        the prefix added to output filenames (default: ttl2c_)
</pre>

You write the turle (ttl) files describing the plugins in your bundle and the python script then generates some useful <code>#include</code>s for you. Below you see the code that's necessary to write when running the script on the amp-plugin example from the lv2 distribution (included here for reference and testing in the <code>lv2/</code> directory)

```C
// Include the generated header
#include "generated/ttl2c_eg_amp.h"

// Implement the one callback necessary. Note how there is one type per port.
static void run (
    plugin_t *instance, uint32_t nframes, 
    const plugin_port_gain_t gain, 
    const plugin_port_in_t in, 
    const plugin_port_out_t out
) {
    for (uint32_t frame = 0; frame < nframes; ++frame) {
        // Each port type has a .data member which hold the
        // connected data location:
        out.data[frame] = gain.data * in.data[frame];
    }
}

// We want run() to be run ;)
static const plugin_callbacks_t plugin_callbacks = {
    .run = run
};

// Include the generated C file
#include "generated/ttl2c_eg_amp.c"


```

# How?

Per plugin a <code>basename</code> is generated by splitting the plugin URI by path separators and just using the last part of the path. Some characters are replaced to make valid C identifiers. In the example <code>http://lv2plug.in/plugins/eg-amp</code> thus becomes <code>eg_amp</code>. The generated source and header file names then get constructed as <code>ttl2c_${basename}.[h|c]</code>.

# An example with state

This example can be found in the file `eg_exp.c`.

```C
#include "generated/ttl2c_eg_exp.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

// This is our state. The name of the type is struct basename_state
// (the generated files assume this precise name):
typedef struct plugin_state {
    float s;
    float sampling_interval;
} plugin_state_t;

// The instantiate callback already gets a plugin_t *instance pointer
// instead of an LV2_Handle and only needs to perform additional
// initialisation.
static plugin_t* instantiate(
    plugin_t *instance, double sample_rate,
    const char *bundle_path, const LV2_Feature *const *features
) {
    instance->state = malloc(sizeof(plugin_state_t));
    memset(instance->state, 0, sizeof(plugin_state_t));
    instance->state->sampling_interval = 1.0f / sample_rate;
    return instance;
}

// And similarly the cleanup callback only needs to care about
// the additional deinitialisation (inverse of instantiate).
static void cleanup(plugin_t *instance) {
    free(instance->state);
}

static void run (
    plugin_t *instance, uint32_t nframes, 
    const plugin_port_t1_t t1,
    const plugin_port_in_t in,
    const plugin_port_out_t out
) {
    plugin_state_t *state = instance->state;

    const float a = 1.0f - expf(-state->sampling_interval/t1.data);
    for (uint32_t frame = 0; frame < nframes; ++frame) {
        out.data[frame] = in.data[frame] * a + state->s * (1 - a);
        state->s = in.data[frame];
    }
}

static const plugin_callbacks_t plugin_callbacks = {
    .instantiate = instantiate,
    .run = run,
    .cleanup = cleanup,
};

#include "generated/ttl2c_eg_exp.c"


```

# An example processing some MIDI

This example can be found in the file `eg_midigate.c`.

```C
#include "generated/ttl2c_eg_midigate.h"
#include <stdlib.h>
#include <string.h>
#include <lv2/midi/midi.h>

typedef struct plugin_state {
    unsigned n_active_notes;
    unsigned program; // 0 = normal, 1 = inverted
} plugin_state_t;

static plugin_t* instantiate(
    plugin_t *instance, double sample_rate,
    const char *bundle_path, const LV2_Feature *const *features
) {
    instance->state = malloc(sizeof(plugin_state_t));
    memset(instance->state, 0, sizeof(plugin_state_t));
    return instance;
}

static void write_output(
    plugin_t* self, uint32_t offset, uint32_t len,
    const plugin_port_in_t in,
    const plugin_port_out_t out
) {
    plugin_state_t *state = self->state;

    const bool active = (state->program == 0) ? (state->n_active_notes > 0)
                                           : (state->n_active_notes == 0);
    if (active) {
        memcpy(out.data + offset, in.data + offset, len * sizeof(float));
    } else {
        memset(out.data + offset, 0, len * sizeof(float));
    }
}

static void run (
    plugin_t *instance, uint32_t nframes, 
    const plugin_port_control_t control,
    const plugin_port_in_t in,
    const plugin_port_out_t out
) {
    plugin_state_t *state = instance->state;
    uint32_t  offset = 0;

    LV2_ATOM_SEQUENCE_FOREACH (control.data, ev) {
        if (ev->body.type == instance->midi_MidiEvent) {
            const uint8_t* const msg = (const uint8_t*)(ev + 1);
            switch (lv2_midi_message_type(msg)) {
            case LV2_MIDI_MSG_NOTE_ON:
                    ++state->n_active_notes;
                break;
            case LV2_MIDI_MSG_NOTE_OFF:
                if (state->n_active_notes > 0) {
                    --state->n_active_notes;
                }
                break;
            case LV2_MIDI_MSG_CONTROLLER:
                if (msg[1] == LV2_MIDI_CTL_ALL_NOTES_OFF) {
                    state->n_active_notes = 0;
                }
                break;
            case LV2_MIDI_MSG_PGM_CHANGE:
                if (msg[1] == 0 || msg[1] == 1) {
                    state->program = msg[1];
                }
                break;
            default:
                break;
            }
        }

        write_output(instance, offset, ev->time.frames - offset, in, out);
        offset = (uint32_t)ev->time.frames;
    }

    write_output(instance, offset, nframes - offset, in, out);
}

static const plugin_callbacks_t plugin_callbacks = {
    .instantiate = instantiate,
    .run = run,
};

#include "generated/ttl2c_eg_midigate.c"


```

# Makefile

Here is the makefile included with this project used to build and test the generated source:

```make
.PHONY: test

EXTRA_CFLAGS ?= -march=native -mcpu=native -O3 -save-temps

all: plugins 

plugins: *.c lv2/example.lv2/*.ttl
	./lv2-ttl2c -b lv2/example.lv2 -o generated 
	gcc ${EXTRA_CFLAGS} eg_amp.c -pedantic -Wall -Werror -shared -o lv2/example.lv2/amp.so
	gcc ${EXTRA_CFLAGS} eg_exp.c -pedantic -Wall -Werror -shared -o lv2/example.lv2/exp.so
	gcc ${EXTRA_CFLAGS} eg_midigate.c -pedantic -Wall -Werror -shared -o lv2/example.lv2/midigate.so

test: plugins
	LV2_PATH=${PWD}/lv2 lv2ls
	LV2_PATH=${PWD}/lv2 lv2info http://lv2plug.in/plugins/eg-amp
	LV2_PATH=${PWD}/lv2 lv2info http://lv2plug.in/plugins/eg-exp
	LV2_PATH=${PWD}/lv2 lv2info http://lv2plug.in/plugins/eg-midigate
	LV2_PATH=${PWD}/lv2 valgrind lv2bench http://lv2plug.in/plugins/eg-amp
	LV2_PATH=${PWD}/lv2 valgrind lv2bench http://lv2plug.in/plugins/eg-exp
	LV2_PATH=${PWD}/lv2 valgrind lv2bench http://lv2plug.in/plugins/eg-midigate

doc: README.md

README.md: README.md.in *.c makefile generated/*.c generated/*.h
	cat README.md.in | regexec | regexec -e "\[usage\]" -c "./lv2-ttl2c -h" -n 1 > README.md

```

# Generated files

For reference here are the two generated files for the second example:

`ttl2c_eg_exp.h`:

```C
#ifndef plugin_cb_hh
#define plugin_cb_hh

#include <lv2.h>
#include <lv2/log/logger.h>
#include <lv2/core/lv2_util.h>
#include <stdint.h>


typedef struct plugin_state plugin_state_t;

typedef struct {
    plugin_state_t *state;
    void *ports[3];
    // No URID map needed
    // No Midi Events needed
    LV2_Log_Logger logger;
} plugin_t;


typedef struct {
    float const data;
} plugin_port_t1_t;

typedef struct {
    float const * const data;
} plugin_port_in_t;

typedef struct {
    float * const data;
} plugin_port_out_t;

typedef struct {
    plugin_t* (*const instantiate)(plugin_t *instance, double sample_rate, const char *bundle_path, const LV2_Feature *const *features);
    void (*const connect_port)(plugin_t *instance, uint32_t port, void *data_location);
    void (*const activate)(plugin_t *instance);
    void (*const run)(plugin_t *instance, uint32_t sample_count, const plugin_port_t1_t t1, const plugin_port_in_t in, const plugin_port_out_t out);
    void (*const deactivate)(plugin_t *instance);
    void (*const cleanup)(plugin_t *instance);
    const void *(*const extension_data)(const char *uri);
} plugin_callbacks_t;

#endif    
```

`ttl2c_eg_exp.c`:

```C
#ifndef plugin_cc
#define plugin_cc
    
#include "ttl2c_eg_exp.h"

#include <lv2.h>
#include <stdlib.h>
#include <string.h>
    
static void plugin_connect_port_desc(LV2_Handle instance, uint32_t port, void *data_location) {
    plugin_t *tinstance = (plugin_t*) instance;

    if (plugin_callbacks.connect_port) {
        plugin_callbacks.connect_port(tinstance, port, data_location);
    } else {
        if (port < 3) {
            (tinstance)->ports[port] = (float*)data_location;
        }
    }
}

static LV2_Handle plugin_instantiate_desc(const LV2_Descriptor *descriptor, double sample_rate, const char *bundle_path, const LV2_Feature *const *features) {
    plugin_t *instance = (plugin_t*)calloc(1, sizeof(plugin_t));

    if (!instance) {
        return NULL;
    }

    memset(instance, 0,  sizeof(plugin_t));

    lv2_features_query(features, LV2_LOG__log, &instance->logger.log, false, NULL);
    

    if (plugin_callbacks.instantiate) {
        instance = plugin_callbacks.instantiate(instance, sample_rate, bundle_path, features);
    }

    return (LV2_Handle)(instance);
}

static void plugin_cleanup_desc(LV2_Handle instance) {
    plugin_t *tinstance = (plugin_t*) instance;

    lv2_log_note(&tinstance->logger, "Cleaning up a http://lv2plug.in/plugins/eg-exp\n");

    if (plugin_callbacks.cleanup) {
        plugin_callbacks.cleanup(tinstance);
    }

    free(tinstance);
}

static void plugin_activate_desc(LV2_Handle instance) {
    plugin_t *tinstance = (plugin_t*) instance;

    if (plugin_callbacks.activate) {
        plugin_callbacks.activate(tinstance);
    }
}

static void plugin_deactivate_desc(LV2_Handle instance) {
    plugin_t *tinstance = (plugin_t*) instance;

    if (plugin_callbacks.deactivate) {
        plugin_callbacks.deactivate(tinstance);
    }
}

static void plugin_run_desc(LV2_Handle instance, uint32_t sample_count) {
    if (plugin_callbacks.run) {
        plugin_t *tinstance = (plugin_t*) instance;

        plugin_port_t1_t const t1 = { .data = ((float*)((plugin_t*)instance)->ports[0])[0] };
        plugin_port_in_t const in = { .data = ((float*)((plugin_t*)instance)->ports[1]) };
        plugin_port_out_t const out = { .data = ((float*)((plugin_t*)instance)->ports[2]) };

        plugin_callbacks.run(tinstance, sample_count, t1, in, out);
    }
}

static const void *plugin_extension_data_desc(const char *uri) {
    if (plugin_callbacks.extension_data) {
        return plugin_callbacks.extension_data(uri);
    } else {
        return 0;
    }
}



static LV2_Descriptor plugin_descriptor = {
    "http://lv2plug.in/plugins/eg-exp",
    plugin_instantiate_desc,
    plugin_connect_port_desc,
    plugin_activate_desc,
    plugin_run_desc,
    plugin_deactivate_desc,
    plugin_cleanup_desc,
    plugin_extension_data_desc
};

LV2_SYMBOL_EXPORT const LV2_Descriptor* lv2_descriptor (uint32_t index) {
    if (0 == index) {
          return &plugin_descriptor;
    } else { 
          return NULL;
    }
}


#endif // plugin_hh

```


# License

Gnu GPL v3



