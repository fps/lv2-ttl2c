# What?

This repository contains a little python script to make writing an LV2 plugin a little less repetitive/painful.

You write the turle (ttl) files describing the plugins in your bundle and the python script then generates some useful <code>#include</code>s for you. Below you see the code that's necessary to write when running the script on the amp-plugin example from the lv2 distribution (included here for reference and testing in the <code>lv2/</code> directory)

```C
// Include the generated header
#include "generated/ttl2c_eg_amp.h"

// Implement the one callback necessary
void run(struct eg_amp *instance, uint32_t nframes, float *gain, float *in, float *out)
{
    for (uint32_t frame = 0; frame < nframes; ++frame)
    {
        out[frame] = gain[0] * in[frame];
    }
}

// We want run() to be run ;)
struct eg_amp_callbacks eg_amp_callbacks = 
{
    .run = run
};

// Include the generated C file
#include "generated/ttl2c_eg_amp.c"


```

# How?

Per plugin a <code>basename</code> is generated by splitting the plugin URI by path separators and just using the last part of the path. Some characters are replaced to make valid C identifiers. In the example <code>http://lv2plug.in/plugins/eg-amp</code> thus becomes <code>eg_amp</code>. The generated source and header file names then get constructed as <code>ttl2c_${basename}.[h|c]</code>.

# An example with state

```C
#include "generated/ttl2c_eg_exp.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

// This is our state. The name of the type is struct basename_state (the generated files assume this precise name):
struct eg_exp_state 
{
    float s;
    float sampling_interval;
};

// The instantiate callback already gets a struct eg_exp *instance pointer instead of an LV2_Handle
// and only needs to perform additional initialisation.
struct eg_exp* instantiate(struct eg_exp *instance, double sample_rate, const char *bundle_path, const LV2_Feature *const *features)
{
    instance->state = malloc(sizeof(struct eg_exp_state));
    memset(instance->state, 0, sizeof(struct eg_exp_state));
    instance->state->sampling_interval = 1.0f / sample_rate;
    return instance;
}

// And similarly the cleanup callback only needs to care about the additional deinitialisation (inverse of instantiate).
void cleanup(struct eg_exp *instance) {
    free(instance->state);
}

void run(struct eg_exp *instance, uint32_t nframes, float *t1, float *in, float *out)
{
    const float a = 1.0f - expf(-instance->state->sampling_interval/t1[0]);
    for (uint32_t frame = 0; frame < nframes; ++frame)
    {
        out[frame] = in[frame] * a + instance->state->s * (1 - a);
        instance->state->s = in[frame];
    }
}

const struct eg_exp_callbacks eg_exp_callbacks = 
{
    .run = run,
    .instantiate = instantiate,
    .cleanup = cleanup,
};

#include "generated/ttl2c_eg_exp.c"

```

# Makefile

Here is the makefile included with this project used to build and test the generated source:

```make
.PHONY: all

all: plugins test doc

plugins:
	./lv2-ttl2c -b lv2/example.lv2/manifest.ttl -o generated 
	gcc eg_amp.c -pedantic -Wall -shared -o lv2/example.lv2/amp.so
	gcc eg_exp.c -pedantic -Wall -shared -o lv2/example.lv2/exp.so

test:
	LV2_PATH=${PWD}/lv2 lv2ls
	LV2_PATH=${PWD}/lv2 lv2info http://lv2plug.in/plugins/eg-amp
	LV2_PATH=${PWD}/lv2 valgrind lv2bench http://lv2plug.in/plugins/eg-amp
	LV2_PATH=${PWD}/lv2 valgrind lv2bench http://lv2plug.in/plugins/eg-exp

doc:
	cat README.md.in | ./regexec > README.md

```

