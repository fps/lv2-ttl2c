#!/usr/bin/env python

import lilv
import argparse
import sys
import pprint
import os
import pathlib

argparser = argparse.ArgumentParser(
    description = 'Generate useful C code from a LV2 plugin bundle\'s metadata',
    formatter_class = argparse.ArgumentDefaultsHelpFormatter)

argparser.add_argument('-b', '--bundle', default='.', help='the bundle directory to analyze')
argparser.add_argument('-o', '--output-directory', default='.', help='the output directory')
argparser.add_argument('-p', '--prefix', default='ttl2c_', help='the prefix added to output filenames')

args = argparser.parse_args()

bundle_file_uri = pathlib.PurePath.as_uri(pathlib.Path(os.path.abspath(args.bundle))) + "/"

# print(os.path.abspath(args.bundle))
# print(bundle_file_uri)

w = lilv.World()
w.load_bundle(bundle_file_uri)

for plugin in w.get_all_plugins():
    file_basename = str(plugin.get_uri()).split("://")[1].split("/")[-1].replace("-","_").replace(".","_")    
    basename = "plugin"
    f = open(os.path.join(args.output_directory, f'{args.prefix}{file_basename}.h'), 'w')
    f.write(f"""\
#ifndef {basename}_cb_hh
#define {basename}_cb_hh

#include <lv2.h>
#include <stdint.h>
 
typedef struct {basename}_state {basename}_state_t;

typedef struct {basename} {{
    struct {basename}_state *state;
    void *ports[{plugin.get_num_ports()}];
}} {basename}_t;

enum {basename}_port_indices {{
""")

    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f'    {port.get_symbol()} = {index},\n')

    f.write(f"""\
}};
""")
    
    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f"""
typedef struct {basename}_port_{port.get_symbol()} {{
    {"float" if not port.is_a(lilv.LILV_URI_ATOM_PORT) else "LV2_Atom_Sequence"} {"const " if port.is_a(lilv.LILV_URI_INPUT_PORT) else ""}{"*" if not port.is_a(lilv.LILV_URI_CONTROL_PORT) else ""}data;
}} {basename}_port_{port.get_symbol()}_t;
""")

    f.write(f"""\

typedef struct {basename}_callbacks {{
    struct {basename}* (*const instantiate)({basename}_t *instance, double sample_rate, const char *bundle_path, const LV2_Feature *const *features);
    void (*const connect_port)({basename}_t *instance, uint32_t port, void *data_location);
    void (*const activate)({basename}_t *instance);
    void (*const run)({basename}_t *instance, uint32_t sample_count""")

    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f", const {basename}_port_{port.get_symbol()}_t {port.get_symbol()}")

    f.write(f""");
    void (*const deactivate)({basename}_t *instance);
    void (*const cleanup)({basename}_t *instance);
    const void *(*const extension_data)(const char *uri);
}} {basename}_callbacks_t;

#endif\
    """)

    f = open(os.path.join(args.output_directory, f'{args.prefix}{file_basename}.c'), 'w')
    f.write(f"""\
#ifndef {basename}_hh
#define {basename}_hh
    
  
#include <lv2.h>
#include <stdlib.h>
#include <string.h>
    
static void {basename}_connect_port_desc(LV2_Handle instance, uint32_t port, void *data_location) {{
    if ({basename}_callbacks.connect_port) {{ 
        {basename}_callbacks.connect_port(({basename}_t *)instance, port, data_location); 
    }} else {{
        if (port < {plugin.get_num_ports()}) {{
            (({basename}_t*)instance)->ports[port] = (float*)data_location;
        }}
    }}
}}

static LV2_Handle {basename}_instantiate_desc(const LV2_Descriptor *descriptor, double sample_rate, const char *bundle_path, const LV2_Feature *const *features) {{
    {basename}_t *instance = ({basename}_t*)calloc(1, sizeof(struct {basename}));
    if (!instance) {{
        return NULL;
    }}

    memset(instance, 0,  sizeof(struct {basename}));
    if ({basename}_callbacks.instantiate) {{
        {basename}_callbacks.instantiate(instance, sample_rate, bundle_path, features);
    }}
    return (LV2_Handle)(instance);
}}

static void {basename}_cleanup_desc(LV2_Handle instance) {{
    if ({basename}_callbacks.cleanup) {{
        {basename}_callbacks.cleanup(({basename}_t*)instance);
    }}

    free(instance);
}}

static void {basename}_activate_desc(LV2_Handle instance) {{
    if ({basename}_callbacks.activate) {{
        {basename}_callbacks.activate(({basename}_t*)instance);
    }}
}}

static void {basename}_deactivate_desc(LV2_Handle instance) {{
    if ({basename}_callbacks.deactivate) {{
        {basename}_callbacks.deactivate(({basename}_t*)instance);
    }}
}}

static void {basename}_run_desc(LV2_Handle instance, uint32_t sample_count) {{
    if ({basename}_callbacks.run) {{
""")
    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f"""\
        const struct {basename}_port_{port.get_symbol()} {port.get_symbol()} = {{ .data = (({"float" if not port.is_a(lilv.LILV_URI_ATOM_PORT) else "LV2_ATOM_SEQUENCE"}*)(({basename}_t*)instance)->ports[{index}]){"[0]" if port.is_a(lilv.LILV_URI_CONTROL_PORT) else ""} }};
""")
    f.write(f"""\

        {basename}_callbacks.run(({basename}_t*)instance, sample_count""")
    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f', {port.get_symbol()}')

    f.write(f""");
    }}
}}

static const void *{basename}_extension_data_desc(const char *uri) {{
    if ({basename}_callbacks.extension_data) {{
        return {basename}_callbacks.extension_data(uri);
    }} else {{
        return 0;
    }}
}}



static LV2_Descriptor {basename}_descriptor = {{
    "{plugin.get_uri()}",
    {basename}_instantiate_desc,
    {basename}_connect_port_desc,
    {basename}_activate_desc,
    {basename}_run_desc,
    {basename}_deactivate_desc,
    {basename}_cleanup_desc,
    {basename}_extension_data_desc
}};

LV2_SYMBOL_EXPORT const LV2_Descriptor* lv2_descriptor (uint32_t index) {{
    if (0 == index) {{
          return &{basename}_descriptor;
    }} else {{ 
          return NULL;
    }}
}}


#endif // {basename}_hh\
    """)



