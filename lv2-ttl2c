#!/usr/bin/env python

import lilv
import argparse
import sys
import pprint
import os
import pathlib

argparser = argparse.ArgumentParser(
    description = 'Generate useful C code from a LV2 plugin bundle\'s metadata',
    formatter_class = argparse.ArgumentDefaultsHelpFormatter)

argparser.add_argument('-b', '--bundle', default='.', help='the bundle directory to analyze')
argparser.add_argument('-o', '--output-directory', default='.', help='the output directory')
argparser.add_argument('-p', '--prefix', default='ttl2c_', help='the prefix added to output filenames')

args = argparser.parse_args()

bundle_file_uri = pathlib.PurePath.as_uri(pathlib.Path(os.path.abspath(args.bundle))) + "/"

# print(os.path.abspath(args.bundle))
# print(bundle_file_uri)

world = lilv.World()
world.load_bundle(bundle_file_uri)

for plugin in world.get_all_plugins():
    file_basename = str(plugin.get_uri()).split("://")[1].split("/")[-1].replace("-","_").replace(".","_")    
    basename = "plugin"
    has_atom_ports = False
    has_midi_ports = False
    needs_urid_map = False
    for port_index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(port_index)
        if port.is_a(lilv.LILV_URI_ATOM_PORT):
            has_atom_ports = True
            if port.supports_event(world.new_uri("http://lv2plug.in/ns/ext/midi#MidiEvent")):
                has_midi_ports = True
                needs_urid_map = True

    f = open(os.path.join(args.output_directory, f'{args.prefix}{file_basename}.h'), 'w')
    f.write(f"""\
#ifndef {basename}_cb_hh
#define {basename}_cb_hh

#include <lv2.h>
#include <lv2/log/logger.h>
#include <lv2/core/lv2_util.h>
#include <stdint.h>
{"#include <lv2/atom/atom.h>" if has_atom_ports else ""}
{"#include <lv2/atom/util.h>" if has_atom_ports else ""}
typedef struct {basename}_state {basename}_state_t;

typedef struct {{
    {basename}_state_t *state;
    void *ports[{plugin.get_num_ports()}];
    {"LV2_URID_Map *map;" if has_midi_ports else "// No URID map"}
    {"LV2_URID midi_MidiEvent;" if needs_urid_map else "// No Midi Events"}
    LV2_Log_Logger logger;
}} {basename}_t;

""")
    
    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f"""
typedef struct {{
    {"float" if not port.is_a(lilv.LILV_URI_ATOM_PORT) else "LV2_Atom_Sequence"} {"const " if port.is_a(lilv.LILV_URI_INPUT_PORT) else ""}{"*" if not port.is_a(lilv.LILV_URI_CONTROL_PORT) else ""}data;
}} {basename}_port_{port.get_symbol()}_t;
""")

    f.write(f"""\

typedef struct {{
    {basename}_t* (*const instantiate)({basename}_t *instance, double sample_rate, const char *bundle_path, const LV2_Feature *const *features);
    void (*const connect_port)({basename}_t *instance, uint32_t port, void *data_location);
    void (*const activate)({basename}_t *instance);
    void (*const run)({basename}_t *instance, uint32_t sample_count""")

    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f", const {basename}_port_{port.get_symbol()}_t {port.get_symbol()}")

    f.write(f""");
    void (*const deactivate)({basename}_t *instance);
    void (*const cleanup)({basename}_t *instance);
    const void *(*const extension_data)(const char *uri);
}} {basename}_callbacks_t;

#endif\
    """)

    f = open(os.path.join(args.output_directory, f'{args.prefix}{file_basename}.c'), 'w')
    f.write(f"""\
#ifndef {basename}_cc
#define {basename}_cc
    
#include "{args.prefix}{file_basename}.h"

#include <lv2.h>
#include <stdlib.h>
#include <string.h>
    
static void {basename}_connect_port_desc(LV2_Handle instance, uint32_t port, void *data_location) {{
    {basename}_t *tinstance = ({basename}_t*) instance;

    if ({basename}_callbacks.connect_port) {{
        {basename}_callbacks.connect_port(tinstance, port, data_location);
    }} else {{
        if (port < {plugin.get_num_ports()}) {{
            (tinstance)->ports[port] = (float*)data_location;
        }}
    }}
}}

static LV2_Handle {basename}_instantiate_desc(const LV2_Descriptor *descriptor, double sample_rate, const char *bundle_path, const LV2_Feature *const *features) {{
    {basename}_t *instance = ({basename}_t*)calloc(1, sizeof({basename}_t));

    if (!instance) {{
        return NULL;
    }}

    memset(instance, 0,  sizeof({basename}_t));

    lv2_features_query(features, LV2_LOG__log, &instance->logger.log, false, NULL);""")

    if needs_urid_map:
        f.write(f"""\

    const char* missing;
    if ((missing = lv2_features_query(features, LV2_URID__map, &instance->map, true, NULL))) {{
        lv2_log_note(&instance->logger, "Missing feature: %s\\n", missing);
        free(instance); return NULL;
    }}""")

    f.write(f"""\

    if ({basename}_callbacks.instantiate) {{
        instance = {basename}_callbacks.instantiate(instance, sample_rate, bundle_path, features);
    }}

    return (LV2_Handle)(instance);
}}

static void {basename}_cleanup_desc(LV2_Handle instance) {{
    {basename}_t *tinstance = ({basename}_t*) instance;

    lv2_log_note(&tinstance->logger, "Cleaning up a {plugin.get_uri()}\\n");

    if ({basename}_callbacks.cleanup) {{
        {basename}_callbacks.cleanup(tinstance);
    }}

    free(tinstance);
}}

static void {basename}_activate_desc(LV2_Handle instance) {{
    {basename}_t *tinstance = ({basename}_t*) instance;

    if ({basename}_callbacks.activate) {{
        {basename}_callbacks.activate(tinstance);
    }}
}}

static void {basename}_deactivate_desc(LV2_Handle instance) {{
    {basename}_t *tinstance = ({basename}_t*) instance;

    if ({basename}_callbacks.deactivate) {{
        {basename}_callbacks.deactivate(tinstance);
    }}
}}

static void {basename}_run_desc(LV2_Handle instance, uint32_t sample_count) {{
    if ({basename}_callbacks.run) {{
        {basename}_t *tinstance = ({basename}_t*) instance;

""")
    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f"""\
        const {basename}_port_{port.get_symbol()}_t {port.get_symbol()} = {{ .data = (({"float" if not port.is_a(lilv.LILV_URI_ATOM_PORT) else "LV2_Atom_Sequence"}*)(({basename}_t*)instance)->ports[{index}]){"[0]" if port.is_a(lilv.LILV_URI_CONTROL_PORT) else ""} }};
""")
    f.write(f"""\

        {basename}_callbacks.run(tinstance, sample_count""")
    for index in range(plugin.get_num_ports()):
        port = plugin.get_port_by_index(index)
        f.write(f', {port.get_symbol()}')

    f.write(f""");
    }}
}}

static const void *{basename}_extension_data_desc(const char *uri) {{
    if ({basename}_callbacks.extension_data) {{
        return {basename}_callbacks.extension_data(uri);
    }} else {{
        return 0;
    }}
}}



static LV2_Descriptor {basename}_descriptor = {{
    "{plugin.get_uri()}",
    {basename}_instantiate_desc,
    {basename}_connect_port_desc,
    {basename}_activate_desc,
    {basename}_run_desc,
    {basename}_deactivate_desc,
    {basename}_cleanup_desc,
    {basename}_extension_data_desc
}};

LV2_SYMBOL_EXPORT const LV2_Descriptor* lv2_descriptor (uint32_t index) {{
    if (0 == index) {{
          return &{basename}_descriptor;
    }} else {{ 
          return NULL;
    }}
}}


#endif // {basename}_hh\
    """)



